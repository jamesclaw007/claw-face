<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claw Face</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: none;
    }

    canvas { display: block; }

    /* ---- Status display ---- */
    #status {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: rgba(150, 150, 160, 0.8);
      letter-spacing: 1px;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 1.5s ease;
      z-index: 10;
      pointer-events: none;
    }
    #status.visible { opacity: 1; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div id="status"></div>


<script>
// ============================================================
// CANVAS SETUP
// ============================================================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const DOT_R = 1.6;
const DOT_SPACING = 4.2;
let DOT_COLOR = '#d8dce8';
let BG_COLOR = '#010108';

let W, H, cx, cy;

// Cached vignette + scanline overlay
let overlayCanvas, overlayCtx;

function resize() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  cx = W / 2;
  cy = H / 2 - H * 0.06;

  // Pre-render static overlay (vignette + scanlines)
  overlayCanvas = document.createElement('canvas');
  overlayCanvas.width = W;
  overlayCanvas.height = H;
  overlayCtx = overlayCanvas.getContext('2d');
  _renderOverlay();
}

function _renderOverlay() {
  // Scanlines
  overlayCtx.fillStyle = 'rgba(0,0,0,0.04)';
  for (let y = 0; y < H; y += 3) overlayCtx.fillRect(0, y, W, 1);
  // Vignette
  const g = overlayCtx.createRadialGradient(cx, cy, Math.min(W,H)*0.2, cx, cy, Math.max(W,H)*0.72);
  g.addColorStop(0, 'rgba(0,0,0,0)');
  g.addColorStop(1, 'rgba(0,0,0,0.5)');
  overlayCtx.fillStyle = g;
  overlayCtx.fillRect(0, 0, W, H);
}

window.addEventListener('resize', resize);
resize();

// ============================================================
// UTILITY FUNCTIONS
// ============================================================
function rnd(a, b) { return a + Math.random() * (b - a); }
function ease(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2; }
function lerp(a, b, t) { return a + (b - a) * t; }

// ============================================================
// ANIMATION STATE
// ============================================================
let currentExpr = 'neutral';
let targetExpr = 'neutral';
let morphT = 1;
const MORPH_SPEED = 3.5;

// Blink
let blinkAmt = 0, blinkPhase = 0, blinkTimer = 0;
let blinkMinMs = 3000;
let blinkMaxMs = 5500;
let blinkInterval = rnd(blinkMinMs, blinkMaxMs);

// Look direction
let lookX = 0, lookY = 0, targetLookX = 0, targetLookY = 0;
let lookTimer = 0, lookInterval = rnd(2000, 5000);
let lookMinMs = 2000;
let lookMaxMs = 5000;

// Breathing & talk
let breathPhase = 0, talkPhase = 0;

// ============================================================
// EXPRESSION AUTO-CYCLING (weighted random, from face.py)
// ============================================================
const EXPRESSION_WEIGHTS = {
  neutral:   25,
  happy:     35,
  sad:        5,
  angry:      3,
  surprised:  8,
  sleepy:    12,
  wink:      12,
  love:       8,
  talking:    5,
};

let autoCycleEnabled = true;
let autoCycleTimer = 0;
let exprMinMs = 8000;
let exprMaxMs = 20000;
let autoCycleInterval = rnd(exprMinMs, exprMaxMs);

function weightedRandomExpression() {
  const names = Object.keys(EXPRESSION_WEIGHTS);
  const weights = names.map(n => EXPRESSION_WEIGHTS[n]);
  const total = weights.reduce((s, w) => s + w, 0);
  let r = Math.random() * total;
  for (let i = 0; i < names.length; i++) {
    r -= weights[i];
    if (r <= 0) return names[i];
  }
  return names[names.length - 1];
}

// ============================================================
// SHAPE PRIMITIVES (dot-matrix geometry)
// ============================================================
function dotsCircle(ox, oy, r) {
  const dots = [], step = DOT_SPACING;
  if (r < 1) return dots;
  const x0 = Math.ceil((ox - r) / step) * step;
  const y0 = Math.ceil((oy - r) / step) * step;
  for (let y = y0; y <= oy + r; y += step) {
    for (let x = x0; x <= ox + r; x += step) {
      const dx = x - ox, dy = y - oy;
      if (dx*dx + dy*dy <= r*r) dots.push([x, y]);
    }
  }
  return dots;
}

function dotsEllipse(ox, oy, rx, ry) {
  const dots = [], step = DOT_SPACING;
  if (rx < 1 || ry < 1) return dots;
  const x0 = Math.ceil((ox - rx) / step) * step;
  const y0 = Math.ceil((oy - ry) / step) * step;
  for (let y = y0; y <= oy + ry; y += step) {
    for (let x = x0; x <= ox + rx; x += step) {
      const dx = (x - ox) / rx, dy = (y - oy) / ry;
      if (dx*dx + dy*dy <= 1) dots.push([x, y]);
    }
  }
  return dots;
}

function dotsHalfCircle(ox, oy, r, side) {
  const dots = [], step = DOT_SPACING;
  if (r < 1) return dots;
  const x0 = Math.ceil((ox - r) / step) * step;
  const y0 = Math.ceil((oy - r) / step) * step;
  for (let y = y0; y <= oy + r; y += step) {
    for (let x = x0; x <= ox + r; x += step) {
      const dx = x - ox, dy = y - oy;
      if (dx*dx + dy*dy <= r*r) {
        if (side === 'top' && dy <= step * 0.5) dots.push([x, y]);
        else if (side === 'bottom' && dy >= -step * 0.5) dots.push([x, y]);
      }
    }
  }
  return dots;
}

function dotsLine(ox, oy, width, thickness) {
  const dots = [], step = DOT_SPACING;
  const hw = width / 2, ht = Math.max(thickness, step * 0.4) / 2;
  const x0 = Math.ceil((ox - hw) / step) * step;
  const y0 = Math.ceil((oy - ht) / step) * step;
  for (let y = y0; y <= oy + ht; y += step) {
    for (let x = x0; x <= ox + hw; x += step) {
      dots.push([x, y]);
    }
  }
  return dots;
}

function dotsArc(ox, oy, radius, startA, endA, thick) {
  const dots = [], step = DOT_SPACING;
  if (radius < 1) return dots;
  const bound = radius + thick + step;
  const x0 = Math.ceil((ox - bound) / step) * step;
  const y0 = Math.ceil((oy - bound) / step) * step;
  for (let y = y0; y <= oy + bound; y += step) {
    for (let x = x0; x <= ox + bound; x += step) {
      const dx = x - ox, dy = y - oy;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < radius - thick || dist > radius + thick) continue;
      let a = Math.atan2(dy, dx);
      if (a < 0) a += Math.PI * 2;
      let s = startA, e = endA;
      if (s < 0) s += Math.PI * 2;
      if (e < 0) e += Math.PI * 2;
      const ok = s <= e ? (a >= s && a <= e) : (a >= s || a <= e);
      if (ok) dots.push([x, y]);
    }
  }
  return dots;
}

function dotsHeart(ox, oy, size) {
  const dots = [], step = DOT_SPACING;
  if (size < 2) return dots;
  const x0 = Math.ceil((ox - size * 1.2) / step) * step;
  const y0 = Math.ceil((oy - size * 1.2) / step) * step;
  for (let y = y0; y <= oy + size * 1.4; y += step) {
    for (let x = x0; x <= ox + size * 1.2; x += step) {
      const nx = (x - ox) / size, ny = -(y - oy) / size + 0.2;
      const eq = nx*nx + ny*ny - 1;
      if (eq*eq*eq - nx*nx * ny*ny*ny <= 0) dots.push([x, y]);
    }
  }
  return dots;
}

// Alias for closed-eye line
function dotsInLine(ox, oy, w, t) { return dotsLine(ox, oy, w, t); }

// ============================================================
// EXPRESSION BUILDER
// ============================================================
function buildExpr(name, s, lx, ly, blink, talk) {
  const sep = 80 * s;
  const eyeY = cy - 30 * s;
  const mouthY = cy + 65 * s;
  const R = 32 * s;
  const lOx = lx * 6 * s, lOy = ly * 4 * s;
  const leX = cx - sep + lOx, reX = cx + sep + lOx, eY = eyeY + lOy;
  const b = 1 - blink;
  let le, re, mo;

  const closedL = () => dotsInLine(leX, eY, R * 1.5, DOT_SPACING);
  const closedR = () => dotsInLine(reX, eY, R * 1.5, DOT_SPACING);

  function stdEyes(ry) {
    if (ry < DOT_SPACING) return [closedL(), closedR()];
    return [dotsCircle(leX, eY, ry), dotsCircle(reX, eY, ry)];
  }

  switch (name) {
    case 'neutral': {
      [le, re] = stdEyes(R * b);
      mo = dotsArc(cx, mouthY, 35*s, Math.PI*0.15, Math.PI*0.85, 4.5*s);
      break;
    }
    case 'happy': {
      const ry = R * 0.9 * b;
      if (ry < DOT_SPACING) { le = closedL(); re = closedR(); }
      else {
        le = dotsHalfCircle(leX, eY + ry*0.35, ry*0.9, 'top');
        re = dotsHalfCircle(reX, eY + ry*0.35, ry*0.9, 'top');
      }
      mo = dotsArc(cx, mouthY - 8*s, 42*s, Math.PI*0.08, Math.PI*0.92, 5.5*s);
      break;
    }
    case 'sad': {
      const ry = R * 0.85 * b;
      if (ry < DOT_SPACING) { le = closedL(); re = closedR(); }
      else { le = dotsCircle(leX, eY + 4*s, ry); re = dotsCircle(reX, eY + 4*s, ry); }
      mo = dotsArc(cx, mouthY + 25*s, 30*s, Math.PI*1.15, Math.PI*1.85, 4*s);
      break;
    }
    case 'angry': {
      const ry = R * 0.55 * b;
      if (ry < DOT_SPACING) { le = closedL(); re = closedR(); }
      else {
        le = dotsEllipse(leX, eY + 6*s, R*1.15, ry);
        re = dotsEllipse(reX, eY + 6*s, R*1.15, ry);
      }
      mo = dotsLine(cx, mouthY + 5*s, 50*s, 5*s);
      break;
    }
    case 'surprised': {
      const big = R * 1.25 * b;
      if (big < DOT_SPACING) { le = closedL(); re = closedR(); }
      else { le = dotsCircle(leX, eY - 5*s, big); re = dotsCircle(reX, eY - 5*s, big); }
      mo = dotsEllipse(cx, mouthY + 8*s, 14*s, 18*s);
      break;
    }
    case 'sleepy': {
      const ry = R * 0.22 * b;
      if (ry < DOT_SPACING) {
        le = dotsLine(leX, eY + 10*s, R*1.3, DOT_SPACING);
        re = dotsLine(reX, eY + 10*s, R*1.3, DOT_SPACING);
      } else {
        le = dotsEllipse(leX, eY + 10*s, R*1.1, ry);
        re = dotsEllipse(reX, eY + 10*s, R*1.1, ry);
      }
      mo = dotsArc(cx, mouthY, 20*s, Math.PI*0.2, Math.PI*0.8, 3.5*s);
      break;
    }
    case 'wink': {
      const ry = R * b;
      re = ry < DOT_SPACING ? closedR() : dotsCircle(reX, eY, ry);
      le = dotsArc(leX, eY + R*0.1, R*0.7, Math.PI*0.05, Math.PI*0.95, 3*s);
      mo = dotsArc(cx + 4*s, mouthY - 2*s, 36*s, Math.PI*0.1, Math.PI*0.85, 4.5*s);
      break;
    }
    case 'love': {
      const hs = 24*s * (b*0.25 + 0.75);
      le = dotsHeart(leX, eY + 2*s, hs);
      re = dotsHeart(reX, eY + 2*s, hs);
      mo = dotsArc(cx, mouthY - 5*s, 38*s, Math.PI*0.08, Math.PI*0.92, 5*s);
      break;
    }
    case 'talking': {
      [le, re] = stdEyes(R * b);
      const mrx = 18*s + Math.abs(Math.sin(talk)) * 12*s;
      const mry = 10*s + Math.abs(Math.sin(talk)) * 16*s;
      mo = dotsEllipse(cx, mouthY + 5*s, mrx, mry);
      break;
    }
    default: {
      [le, re] = stdEyes(R);
      mo = dotsArc(cx, mouthY, 35*s, Math.PI*0.15, Math.PI*0.85, 4.5*s);
    }
  }

  return { le, re, mo };
}

// ============================================================
// INTERPOLATION & RENDERING
// ============================================================
function morphDots(from, to, t) {
  const res = [], len = Math.max(from.length, to.length);
  if (!len) return res;
  for (let i = 0; i < len; i++) {
    const f = from[i % from.length] || to[i];
    const g = to[i % to.length] || from[i];
    res.push([
      lerp(f[0], g[0], t),
      lerp(f[1], g[1], t),
      i < to.length ? (i < from.length ? 1 : t) : (1 - t)
    ]);
  }
  return res;
}

function drawDots(dots) {
  // Batch all full-opacity dots into a single path (vast majority of frames)
  ctx.fillStyle = DOT_COLOR;
  ctx.beginPath();
  for (const d of dots) {
    const a = d[2] ?? 1;
    if (a < 0.04 || a <= 0.96) continue;
    ctx.moveTo(d[0] + DOT_R, d[1]);
    ctx.arc(d[0], d[1], DOT_R, 0, Math.PI * 2);
  }
  ctx.fill();

  // Partially transparent dots during morphing (individual alpha)
  for (const d of dots) {
    const a = d[2] ?? 1;
    if (a < 0.04 || a > 0.96) continue;
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.arc(d[0], d[1], DOT_R, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// ============================================================
// STATUS DISPLAY
// ============================================================
const statusEl = document.getElementById('status');
let statusCheckInterval = 7000;

function fetchStatus() {
  fetch('/api/status')
    .then(r => r.ok ? r.json() : Promise.reject())
    .then(data => {
      if (data.text) {
        statusEl.textContent = 'Working on: ' + data.text;
        statusEl.classList.add('visible');
      } else {
        statusEl.classList.remove('visible');
      }
    })
    .catch(() => {
      // Silently ignore - works standalone without server
      statusEl.classList.remove('visible');
    });
}
setInterval(fetchStatus, statusCheckInterval);
fetchStatus();

// ============================================================
// CONFIG FETCH (optional, override defaults from server)
// ============================================================
function rgb(arr, fallback) {
  if (!Array.isArray(arr) || arr.length < 3) return fallback;
  const r = Math.max(0, Math.min(255, arr[0] | 0));
  const g = Math.max(0, Math.min(255, arr[1] | 0));
  const b = Math.max(0, Math.min(255, arr[2] | 0));
  return `rgb(${r}, ${g}, ${b})`;
}

fetch('/api/config')
  .then(r => r.ok ? r.json() : Promise.reject())
  .then(cfg => {
    if (cfg.colors) {
      if (cfg.colors.background) BG_COLOR = rgb(cfg.colors.background, BG_COLOR);
      if (cfg.colors.eye_white) DOT_COLOR = rgb(cfg.colors.eye_white, DOT_COLOR);
    }
    if (cfg.behavior) {
      if (cfg.behavior.blink_interval_min != null || cfg.behavior.blink_interval_max != null) {
        blinkMinMs = (cfg.behavior.blink_interval_min || 3) * 1000;
        blinkMaxMs = (cfg.behavior.blink_interval_max || 5.5) * 1000;
        blinkInterval = rnd(blinkMinMs, blinkMaxMs);
      }
      if (cfg.behavior.expression_interval_min != null || cfg.behavior.expression_interval_max != null) {
        exprMinMs = (cfg.behavior.expression_interval_min || 8) * 1000;
        exprMaxMs = (cfg.behavior.expression_interval_max || 20) * 1000;
        autoCycleInterval = rnd(exprMinMs, exprMaxMs);
      }
      if (cfg.behavior.look_interval_min != null || cfg.behavior.look_interval_max != null) {
        lookMinMs = (cfg.behavior.look_interval_min || 2) * 1000;
        lookMaxMs = (cfg.behavior.look_interval_max || 5) * 1000;
        lookInterval = rnd(lookMinMs, lookMaxMs);
      }
    }
    if (cfg.display && cfg.display.fps != null) {
      const fps = Math.max(1, Math.min(240, cfg.display.fps | 0));
      TARGET_FPS = fps;
      FRAME_TIME = 1000 / TARGET_FPS;
    }
  })
  .catch(() => {
    // Standalone mode - use defaults
  });

// ============================================================
// COMMAND FETCH (optional: external control via command.json)
// ============================================================
const KNOWN_EXPRS = new Set([
  'neutral', 'happy', 'sad', 'angry', 'surprised', 'sleepy', 'wink', 'love', 'talking'
]);

function fetchCommand() {
  fetch('/api/command')
    .then(r => r.ok ? r.json() : Promise.reject())
    .then(cmd => {
      if (cmd && typeof cmd === 'object') {
        if (typeof cmd.expression === 'string' && KNOWN_EXPRS.has(cmd.expression)) {
          setExpression(cmd.expression);
        }
        if (typeof cmd.auto_cycle === 'boolean') {
          autoCycleEnabled = cmd.auto_cycle;
          autoCycleTimer = 0;
        }
      }
    })
    .catch(() => {
      // Standalone mode - ignore
    });
}
setInterval(fetchCommand, 1000);

// ============================================================
// MAIN LOOP (throttled to 30fps)
// ============================================================
let TARGET_FPS = 30;
let FRAME_TIME = 1000 / TARGET_FPS;
let lastT = performance.now();
let accumulator = 0;

function frame() {
  const now = performance.now();
  const elapsed = now - lastT;
  lastT = now;
  accumulator += elapsed;

  // Throttle: skip render if not enough time has passed
  if (accumulator < FRAME_TIME) {
    requestAnimationFrame(frame);
    return;
  }
  const dt = Math.min(accumulator, 50);
  accumulator = 0;

  // --- Blink ---
  blinkTimer += dt;
  if (blinkPhase === 0 && blinkTimer >= blinkInterval) {
    blinkPhase = 1;
    blinkTimer = 0;
  }
  if (blinkPhase === 1) {
    blinkAmt += dt * 0.009;
    if (blinkAmt >= 1) { blinkAmt = 1; blinkPhase = 2; }
  }
  if (blinkPhase === 2) {
    blinkAmt -= dt * 0.007;
    if (blinkAmt <= 0) {
      blinkAmt = 0;
      blinkPhase = 0;
      blinkInterval = rnd(blinkMinMs, blinkMaxMs);
      blinkTimer = 0;
    }
  }

  // --- Look direction ---
  lookTimer += dt;
  if (lookTimer >= lookInterval) {
    targetLookX = rnd(-1, 1);
    targetLookY = rnd(-0.5, 0.5);
    lookInterval = rnd(lookMinMs, lookMaxMs);
    lookTimer = 0;
  }
  lookX += (targetLookX - lookX) * 0.05;
  lookY += (targetLookY - lookY) * 0.05;

  // --- Breathing & talk ---
  breathPhase += dt * 0.0018;
  if (targetExpr === 'talking') talkPhase += dt * 0.013;

  // --- Expression morph ---
  if (morphT < 1) {
    morphT += dt * 0.001 * MORPH_SPEED;
    if (morphT > 1) morphT = 1;
  }

  // --- Auto-cycle expressions ---
  if (autoCycleEnabled) {
    autoCycleTimer += dt;
    if (autoCycleTimer >= autoCycleInterval) {
      const chosen = weightedRandomExpression();
      setExpression(chosen);
      autoCycleTimer = 0;
      autoCycleInterval = rnd(exprMinMs, exprMaxMs);
    }
  }

  // --- Draw ---
  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = BG_COLOR;
  ctx.fillRect(0, 0, W, H);
  // Build geometry at base scale, apply breathing via canvas transform
  const baseS = Math.min(W, H) / 260;
  const breathScale = 1 + Math.sin(breathPhase) * 0.012;
  const from = buildExpr(currentExpr, baseS, lookX, lookY, blinkAmt, talkPhase);
  const to = buildExpr(targetExpr, baseS, lookX, lookY, blinkAmt, talkPhase);
  const t = ease(morphT);

  const all = [
    ...morphDots(from.le, to.le, t),
    ...morphDots(from.re, to.re, t),
    ...morphDots(from.mo, to.mo, t),
  ];

  ctx.save();
  ctx.translate(cx, cy);
  ctx.scale(breathScale, breathScale);
  ctx.translate(-cx, -cy);
  drawDots(all);
  ctx.restore();

  // Cached overlay (scanlines + vignette)
  ctx.drawImage(overlayCanvas, 0, 0);


  requestAnimationFrame(frame);
}

// ============================================================
// INPUT HANDLING
// ============================================================
function setExpression(name) {
  if (name === targetExpr && morphT >= 1) return;
  currentExpr = targetExpr;
  targetExpr = name;
  morphT = 0;
}

function manualBlink() {
  // Trigger a blink ASAP if not already blinking.
  if (blinkPhase === 0) {
    blinkPhase = 1;
    blinkTimer = 0;
  }
}

function toggleFullscreen() {
  // Browser fullscreen first; if unsupported (or running in pywebview), ask the server.
  const el = document.documentElement;
  const can = !!(el.requestFullscreen && document.exitFullscreen);
  if (can) {
    if (document.fullscreenElement) {
      document.exitFullscreen().catch(() => {});
    } else {
      el.requestFullscreen().catch(() => {
        fetch('/api/fullscreen/toggle').catch(() => {});
      });
    }
    return;
  }
  fetch('/api/fullscreen/toggle').catch(() => {});
}

document.addEventListener('keydown', e => {
  const k = e.key;
  if (k === 'Escape' || k === 'q' || k === 'Q') {
    fetch('/api/quit').catch(() => {});
    return;
  }
  if (k === ' ') {
    autoCycleEnabled = !autoCycleEnabled;
    autoCycleTimer = 0;
    return;
  }
  if (k === 'b' || k === 'B') {
    manualBlink();
    return;
  }
  if (k === 'f' || k === 'F') {
    toggleFullscreen();
    return;
  }

  // Expression hotkeys: 1-9
  const exprs = [
    'neutral',
    'happy',
    'sad',
    'angry',
    'surprised',
    'sleepy',
    'wink',
    'love',
    'talking',
  ];
  const n = (k && k.length === 1) ? (k.charCodeAt(0) - 48) : -1;
  if (n >= 1 && n <= exprs.length) {
    setExpression(exprs[n - 1]);
  }
});

// ============================================================
// START
// ============================================================
requestAnimationFrame(frame);
</script>
</body>
</html>
