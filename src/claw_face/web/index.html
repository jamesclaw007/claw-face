<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claw Face</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: none;
    }
    canvas { display: block; }
    .scanlines {
      position: absolute;
      pointer-events: none;
      background-image:
        linear-gradient(rgba(0,0,0,0.06) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,0,0,0.06) 1px, transparent 1px);
      opacity: 0.6;
    }
  </style>
</head>
<body>
  <canvas id="oled"></canvas>
  <div class="scanlines" id="scanlines"></div>

<script>
// ============================================================
// OLED ROBOT EYES ENGINE — Cozmo-inspired parametric system
// Replaces dot-matrix renderer. Single-file, no external deps.
// ============================================================

const canvas = document.getElementById('oled');
const C = canvas.getContext('2d');

// Virtual OLED dimensions and scale
const VW = 128, VH = 64;
let S = 4; // scale factor, recalculated on resize

let EYE_COLOR = '#00b8ff';
let BG_COLOR = '#000000';

const scanlines = document.getElementById('scanlines');

function resize() {
  // Fill the screen, maintaining the 2:1 aspect ratio of the virtual OLED
  const ww = window.innerWidth, wh = window.innerHeight;
  const aspect = VW / VH; // 2:1
  let w, h;
  if (ww / wh > aspect) {
    h = wh;
    w = h * aspect;
  } else {
    w = ww;
    h = w / aspect;
  }
  S = w / VW;
  canvas.width = Math.round(w);
  canvas.height = Math.round(h);

  // Position grid overlay to match canvas
  const grid = Math.round(S) + 'px';
  scanlines.style.width = canvas.width + 'px';
  scanlines.style.height = canvas.height + 'px';
  scanlines.style.left = ((ww - canvas.width) / 2) + 'px';
  scanlines.style.top = ((wh - canvas.height) / 2) + 'px';
  scanlines.style.backgroundSize = grid + ' ' + grid;
}
window.addEventListener('resize', resize);
resize();

// ============================================================
// EASING
// ============================================================
function lerp(a, b, t) { return a + (b - a) * t; }
function smoothStep(a, b, speed, dt) {
  return lerp(a, b, 1 - Math.pow(1 - speed, dt * 60));
}
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

// ============================================================
// EXPRESSION PRESETS (Cozmo/esp32-eyes style)
// Per-eye: w, h (size add), offY, tiltTop/tiltBot (lid angle px),
//   lidTop/lidBot (closure 0-1), scaleX
// ============================================================
const PRESETS = {
  normal: {
    L: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    R: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    transitionSpeed: 6,
  },
  happy: {
    L: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    R: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    pupilScale: 1.5, transitionSpeed: 7,
  },
  sad: {
    L: { w:-2, h:-3, offY:2, tiltTop:5, tiltBot:0, lidTop:0.25, lidBot:0, scaleX:0.95 },
    R: { w:-2, h:-3, offY:2, tiltTop:-5, tiltBot:0, lidTop:0.25, lidBot:0, scaleX:0.95 },
    transitionSpeed: 4,
  },
  angry: {
    L: { w:3, h:-4, offY:0, tiltTop:-7, tiltBot:0, lidTop:0.38, lidBot:0, scaleX:1.08 },
    R: { w:3, h:-4, offY:0, tiltTop:7, tiltBot:0, lidTop:0.38, lidBot:0, scaleX:1.08 },
    transitionSpeed: 8,
  },
  surprised: {
    L: { w:6, h:8, offY:-2, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    R: { w:6, h:8, offY:-2, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    transitionSpeed: 10,
  },
  suspicious: {
    L: { w:1, h:-8, offY:1, tiltTop:-4, tiltBot:2, lidTop:0.30, lidBot:0.20, scaleX:1.1 },
    R: { w:-2, h:-4, offY:0, tiltTop:0, tiltBot:0, lidTop:0.10, lidBot:0, scaleX:0.9 },
    transitionSpeed: 5,
  },
  cute: {
    L: { w:5, h:5, offY:1, tiltTop:0, tiltBot:-2, lidTop:0, lidBot:0.30, scaleX:1 },
    R: { w:5, h:5, offY:1, tiltTop:0, tiltBot:2, lidTop:0, lidBot:0.30, scaleX:1 },
    transitionSpeed: 6,
  },
  tired: {
    L: { w:-1, h:-6, offY:3, tiltTop:3, tiltBot:0, lidTop:0.42, lidBot:0, scaleX:0.95 },
    R: { w:-1, h:-6, offY:3, tiltTop:-3, tiltBot:0, lidTop:0.42, lidBot:0, scaleX:0.95 },
    transitionSpeed: 3,
  },
  wonder: {
    L: { w:4, h:7, offY:-1, tiltTop:2, tiltBot:0, lidTop:0, lidBot:0, scaleX:0.95 },
    R: { w:6, h:9, offY:-2, tiltTop:-2, tiltBot:0, lidTop:0, lidBot:0, scaleX:1.05 },
    transitionSpeed: 6,
  },
  upset: {
    L: { w:0, h:-2, offY:2, tiltTop:6, tiltBot:-2, lidTop:0.18, lidBot:0.10, scaleX:1 },
    R: { w:0, h:-2, offY:2, tiltTop:-6, tiltBot:2, lidTop:0.18, lidBot:0.10, scaleX:1 },
    transitionSpeed: 5,
  },
  confused: {
    L: { w:-3, h:2, offY:-2, tiltTop:4, tiltBot:0, lidTop:0.15, lidBot:0, scaleX:0.9 },
    R: { w:4, h:4, offY:1, tiltTop:-2, tiltBot:0, lidTop:0, lidBot:0, scaleX:1.1 },
    transitionSpeed: 6,
  },
  scared: {
    L: { w:5, h:8, offY:-1, tiltTop:4, tiltBot:0, lidTop:0, lidBot:0.05, scaleX:0.92 },
    R: { w:5, h:8, offY:-1, tiltTop:-4, tiltBot:0, lidTop:0, lidBot:0.05, scaleX:0.92 },
    transitionSpeed: 10,
  },
  sleepy: {
    L: { w:-2, h:-12, offY:4, tiltTop:2, tiltBot:0, lidTop:0.55, lidBot:0, scaleX:1 },
    R: { w:-2, h:-12, offY:4, tiltTop:-2, tiltBot:0, lidTop:0.55, lidBot:0, scaleX:1 },
    transitionSpeed: 2,
  },
  glee: {
    L: { w:3, h:-4, offY:0, tiltTop:0, tiltBot:-5, lidTop:0, lidBot:0.50, scaleX:1.1 },
    R: { w:3, h:-4, offY:0, tiltTop:0, tiltBot:5, lidTop:0, lidBot:0.50, scaleX:1.1 },
    transitionSpeed: 8,
  },
  skeptic: {
    L: { w:0, h:0, offY:0, tiltTop:-5, tiltBot:0, lidTop:0.35, lidBot:0, scaleX:1 },
    R: { w:2, h:4, offY:-1, tiltTop:2, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    transitionSpeed: 5,
  },
};

// Compatibility map: old expression names -> new canonical names
const COMPAT_MAP = {
  neutral: 'normal',
  love: 'cute',
  focused: 'suspicious',
  thinking: 'skeptic',
  excited: 'glee',
  glitch: 'scared',
  smug: 'skeptic',
  sleep: 'sleepy',
};

// All known expression names (canonical + compat)
const KNOWN_EXPRS = new Set([
  ...Object.keys(PRESETS),
  ...Object.keys(COMPAT_MAP),
  'wink', 'talking', 'typing',
]);

// Resolve an expression name, applying compat mapping
function resolveExpr(name) {
  if (name === 'wink') return '__wink__';
  if (name === 'talking' || name === 'typing') return 'normal';
  if (PRESETS[name]) return name;
  if (COMPAT_MAP[name]) return COMPAT_MAP[name];
  return null;
}

// ============================================================
// EXPRESSION WEIGHTS (for auto-cycling)
// ============================================================
const EXPRESSION_WEIGHTS = {
  normal:     25,
  happy:      35,
  sad:         5,
  angry:       3,
  surprised:   8,
  suspicious:  6,
  cute:        6,
  tired:       4,
  wonder:      5,
  upset:       3,
  confused:    3,
  scared:      1,
  sleepy:     12,
  glee:        4,
  skeptic:     6,
};

function weightedRandomExpression() {
  const names = Object.keys(EXPRESSION_WEIGHTS);
  const weights = names.map(n => EXPRESSION_WEIGHTS[n]);
  const total = weights.reduce((s, w) => s + w, 0);
  let r = Math.random() * total;
  for (let i = 0; i < names.length; i++) {
    r -= weights[i];
    if (r <= 0) return names[i];
  }
  return names[names.length - 1];
}

// ============================================================
// STATE
// ============================================================
const eye = {
  baseW: 28, baseH: 36, gap: 40, cornerR: 8,
  // Current per-eye interpolated state
  L: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
  R: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
  // Gaze
  gazeTargX: 0, gazeTargY: 0, gazeX: 0, gazeY: 0,
  // Blink (0=open, 1=closed)
  blinkL: 0, blinkR: 0, blinkLDir: 0, blinkRDir: 0,
  // Sleeping
  sleeping: false, sleepT: 0,
  // Confusion offset
  confL: 0, confR: 0, confTimer: 0,
  // Transition speed
  tSpeed: 6,
  // Pupil scale modifier
  pupilScale: 1,
  // Current mood
  mood: 'normal',
  // Happy wink state
  happyWinkTimer: 0.5 + Math.random() * 0.8, happyWinkSide: 0,
  // Toggles
  autoBlink: true,
  // Timers
  blinkTimer: 2 + Math.random() * 3,
};

// Auto-cycle
let autoCycleEnabled = true;
let autoCycleTimer = 0;
let exprMinMs = 8000;
let exprMaxMs = 20000;
let autoCycleInterval = exprMinMs + Math.random() * (exprMaxMs - exprMinMs);

// Blink timing (configurable from /api/config)
let blinkMinS = 1.5;
let blinkMaxS = 4.0;

// Look timing
let lookMinS = 1.0;
let lookMaxS = 3.0;

// External command state
let cmdIntensity = null;
let lookOverride = null;
let lastBlinkSeq = null;
let lastSequenceSeq = null;
let activeSequence = null;

// FPS throttle
let TARGET_FPS = 30;
let FRAME_TIME = 1000 / TARGET_FPS;

function setMood(name) {
  if (!PRESETS[name]) return;
  eye.mood = name;
  eye.tSpeed = PRESETS[name].transitionSpeed;
  eye.happyWinkTimer = 0.5 + Math.random() * 0.8;
  eye.happyWinkSide = 0;
}

function setExpression(rawName) {
  const resolved = resolveExpr(rawName);
  if (!resolved) return;
  if (resolved === '__wink__') {
    doWinkL();
    setMood('happy');
    return;
  }
  eye.sleeping = false;
  setMood(resolved);
}

// ============================================================
// DRAWING PRIMITIVES
// ============================================================
function fillRoundRect(x, y, w, h, r) {
  r = Math.min(r, w / 2, h / 2);
  if (r < 0) r = 0;
  C.beginPath();
  C.moveTo((x + r) * S, y * S);
  C.lineTo((x + w - r) * S, y * S);
  C.quadraticCurveTo((x + w) * S, y * S, (x + w) * S, (y + r) * S);
  C.lineTo((x + w) * S, (y + h - r) * S);
  C.quadraticCurveTo((x + w) * S, (y + h) * S, (x + w - r) * S, (y + h) * S);
  C.lineTo((x + r) * S, (y + h) * S);
  C.quadraticCurveTo(x * S, (y + h) * S, x * S, (y + h - r) * S);
  C.lineTo(x * S, (y + r) * S);
  C.quadraticCurveTo(x * S, y * S, (x + r) * S, y * S);
  C.closePath();
  C.fill();
}

function drawEye(cx, cy, baseW, baseH, r, ep, blink, pupilScale, gazeX, gazeY) {
  const ew = (baseW + ep.w) * ep.scaleX;
  const fullH = baseH + ep.h;
  const minH = 3;
  const eh = Math.max(minH, fullH * (1 - blink));
  const oy = ep.offY * (1 - blink * 0.7);
  const x = cx - ew / 2;
  const y = cy - eh / 2 + oy;

  // Main eye shape
  C.fillStyle = EYE_COLOR;
  fillRoundRect(x, y, ew, eh, Math.min(r, eh / 2));

  // Pupil (black center) — only when eye is open enough
  if (eh > 8) {
    const ps = pupilScale || 1;
    const pupilW = ew * 0.38 * ps;
    const pupilH = eh * 0.40 * ps;
    const pupilR = Math.min(Math.min(r, pupilW / 2, pupilH / 2), 6 * ps);
    const maxShiftX = (ew - pupilW) * 0.45;
    const maxShiftY = (eh - pupilH) * 0.45;
    const px = cx - pupilW / 2 + gazeX * maxShiftX;
    const py = cy + oy - pupilH / 2 + gazeY * maxShiftY;
    C.fillStyle = BG_COLOR;
    fillRoundRect(px, py, pupilW, pupilH, pupilR);
  }

  // Angled top lid
  if (ep.lidTop > 0.02 || Math.abs(ep.tiltTop) > 0.5) {
    const lidH = eh * Math.max(ep.lidTop, 0) + Math.abs(ep.tiltTop);
    if (lidH > 0.5) {
      C.fillStyle = BG_COLOR;
      C.beginPath();
      const lx = (x - 2) * S, rx = (x + ew + 2) * S;
      const lyTop = (y - 3) * S;
      const lyBot = (y + lidH + ep.tiltTop) * S;
      const ryBot = (y + lidH - ep.tiltTop) * S;
      C.moveTo(lx, lyTop); C.lineTo(rx, lyTop);
      C.lineTo(rx, ryBot); C.lineTo(lx, lyBot);
      C.closePath(); C.fill();
    }
  }

  // Angled bottom lid
  if (ep.lidBot > 0.02 || Math.abs(ep.tiltBot) > 0.5) {
    const lidH = eh * Math.max(ep.lidBot, 0) + Math.abs(ep.tiltBot);
    if (lidH > 0.5) {
      C.fillStyle = BG_COLOR;
      C.beginPath();
      const lx = (x - 2) * S, rx = (x + ew + 2) * S;
      const lyBot = (y + eh + 3) * S;
      const lyTop = (y + eh - lidH + ep.tiltBot) * S;
      const ryTop = (y + eh - lidH - ep.tiltBot) * S;
      C.moveTo(lx, lyTop); C.lineTo(rx, ryTop);
      C.lineTo(rx, lyBot); C.lineTo(lx, lyBot);
      C.closePath(); C.fill();
    }
  }
}

// ============================================================
// STATUS TICKER (typing/hold/erase state machine)
// ============================================================
const statusState = {
  currentText: '',   // what we're currently displaying/targeting
  displayText: '',   // what's visible right now
  charIdx: 0,
  phase: 'idle',     // 'idle' | 'typing' | 'hold' | 'erasing' | 'erase_then_type'
  timer: 0,
  typeSpeed: 0.04,
  eraseSpeed: 0.02,
  pendingText: null,  // queued text to type after erase
  serverText: '',     // last text received from server
};

function setStatusText(text) {
  const ss = statusState;
  if (text === ss.serverText) return;
  ss.serverText = text;

  if (!text) {
    // Empty: erase current and go idle
    if (ss.displayText) {
      ss.phase = 'erasing';
      ss.pendingText = null;
      ss.timer = 0;
    } else {
      ss.phase = 'idle';
    }
    return;
  }

  if (ss.phase === 'idle' && !ss.displayText) {
    // Nothing showing — type it directly
    ss.currentText = text;
    ss.charIdx = 0;
    ss.displayText = '';
    ss.phase = 'typing';
    ss.timer = 0;
  } else {
    // Something showing — erase first, then type new
    ss.pendingText = text;
    if (ss.phase !== 'erasing' && ss.phase !== 'erase_then_type') {
      ss.phase = 'erase_then_type';
      ss.timer = 0;
    }
  }
}

function updateStatus(dt) {
  const ss = statusState;
  if (ss.phase === 'idle') return;
  ss.timer += dt;

  if (ss.phase === 'typing') {
    if (ss.timer >= ss.typeSpeed) {
      ss.timer = 0;
      ss.charIdx++;
      ss.displayText = ss.currentText.substring(0, ss.charIdx);
      if (ss.charIdx >= ss.currentText.length) {
        ss.phase = 'hold';
        ss.timer = 0;
      }
    }
  } else if (ss.phase === 'hold') {
    if (ss.pendingText != null) {
      // New text waiting — start erasing
      ss.phase = 'erase_then_type';
      ss.timer = 0;
    }
    // No auto-erase — status persists until server clears or changes it
  } else if (ss.phase === 'erasing' || ss.phase === 'erase_then_type') {
    if (ss.timer >= ss.eraseSpeed) {
      ss.timer = 0;
      ss.charIdx--;
      ss.displayText = ss.currentText.substring(0, Math.max(0, ss.charIdx));
      if (ss.charIdx <= 0) {
        if (ss.phase === 'erase_then_type' && ss.pendingText) {
          ss.currentText = ss.pendingText;
          ss.pendingText = null;
          ss.charIdx = 0;
          ss.displayText = '';
          ss.phase = 'typing';
          ss.timer = 0;
        } else {
          ss.displayText = '';
          ss.phase = 'idle';
          ss.pendingText = null;
        }
      }
    }
  }
}

function renderStatus() {
  const ss = statusState;
  if (!ss.displayText && ss.phase === 'idle') return;

  const fontSize = 7;
  C.font = `${fontSize * S}px "Share Tech Mono", monospace`;
  C.textBaseline = 'top';
  C.textAlign = 'center';
  C.fillStyle = '#006a8a';
  const text = ss.displayText || '';
  const textY = 54;
  C.fillText(text, (VW / 2) * S, textY * S);

  // Blinking cursor
  if (ss.phase === 'typing') {
    const textW = C.measureText(text).width;
    const cursorX = (VW / 2) * S + textW / 2;
    C.fillStyle = EYE_COLOR;
    C.fillRect(cursorX + 1, textY * S, 2 * S, fontSize * S);
  }
  C.textAlign = 'left';
}

// ============================================================
// ACTIONS
// ============================================================
function doBlink() {
  eye.blinkLDir = 1; eye.blinkL = 0;
  eye.blinkRDir = 1; eye.blinkR = 0;
}
function doWinkL() { eye.blinkLDir = 1; eye.blinkL = 0; }
function doWinkR() { eye.blinkRDir = 1; eye.blinkR = 0; }

// ============================================================
// SEQUENCES (boot, error_pulse)
// ============================================================
function startSequence(name) {
  const n = typeof name === 'string' ? name : '';
  const now = performance.now();
  if (n === 'boot') {
    activeSequence = { name: 'boot', untilMs: now + 1600, stage: 0, startMs: now };
    setExpression('glee');
    doBlink();
    return;
  }
  if (n === 'error_pulse') {
    activeSequence = { name: 'error_pulse', untilMs: now + 900, stage: 0, startMs: now };
    setExpression('scared');
    return;
  }
}

// ============================================================
// RENDER
// ============================================================
function render() {
  C.fillStyle = BG_COLOR;
  C.fillRect(0, 0, canvas.width, canvas.height);

  const e = eye;
  const leftCX = VW / 2 - e.gap / 2 + e.confL;
  const rightCX = VW / 2 + e.gap / 2 + e.confR;
  const cy = VH / 2 - 5;

  const sleepBlink = e.sleepT * 0.92;
  const blinkL = Math.max(e.blinkL, sleepBlink);
  const blinkR = Math.max(e.blinkR, sleepBlink);

  drawEye(leftCX, cy, e.baseW, e.baseH, e.cornerR, e.L, blinkL, e.pupilScale, e.gazeX, e.gazeY);
  drawEye(rightCX, cy, e.baseW, e.baseH, e.cornerR, e.R, blinkR, e.pupilScale, e.gazeX, e.gazeY);

  renderStatus();
}

// ============================================================
// UPDATE LOOP
// ============================================================
let lastT = 0;
let accumulator = 0;

function frame(ts) {
  const elapsed = ts - lastT;
  lastT = ts;
  accumulator += elapsed;

  if (accumulator < FRAME_TIME) {
    requestAnimationFrame(frame);
    return;
  }
  const dtMs = Math.min(accumulator, 50);
  const dt = dtMs / 1000;
  accumulator = 0;

  const e = eye;
  const spd = e.tSpeed;
  const preset = PRESETS[e.mood];

  // Interpolate per-eye params toward preset
  const fields = ['w', 'h', 'offY', 'tiltTop', 'tiltBot', 'lidTop', 'lidBot', 'scaleX'];
  for (const f of fields) {
    e.L[f] = smoothStep(e.L[f], preset.L[f], spd * 0.08, dt);
    e.R[f] = smoothStep(e.R[f], preset.R[f], spd * 0.08, dt);
  }

  // Interpolate pupil scale
  const targetPS = preset.pupilScale || 1;
  e.pupilScale = smoothStep(e.pupilScale, targetPS, spd * 0.08, dt);

  // Gaze smoothing
  let gazeTargX = e.gazeTargX, gazeTargY = e.gazeTargY;
  if (lookOverride) {
    gazeTargX = lookOverride.x;
    gazeTargY = lookOverride.y;
  }
  const gazeSpd = (lookOverride || e.gazeTargX !== 0 || e.gazeTargY !== 0) ? 8 * 0.08 : 2 * 0.08;
  e.gazeX = smoothStep(e.gazeX, gazeTargX, gazeSpd, dt);
  e.gazeY = smoothStep(e.gazeY, gazeTargY, gazeSpd, dt);

  // Blink animation
  if (e.blinkLDir) {
    e.blinkL += e.blinkLDir * 0.18 * dt * 60;
    if (e.blinkL >= 1) { e.blinkL = 1; e.blinkLDir = -1; }
    if (e.blinkL <= 0) { e.blinkL = 0; e.blinkLDir = 0; }
  }
  if (e.blinkRDir) {
    e.blinkR += e.blinkRDir * 0.18 * dt * 60;
    if (e.blinkR >= 1) { e.blinkR = 1; e.blinkRDir = -1; }
    if (e.blinkR <= 0) { e.blinkR = 0; e.blinkRDir = 0; }
  }

  // Sleep
  if (e.sleeping) e.sleepT = Math.min(1, e.sleepT + dt * 1.5);
  else e.sleepT = Math.max(0, e.sleepT - dt * 3);

  // Confusion decay
  if (e.confTimer > 0) {
    e.confTimer -= dt;
    if (e.confTimer <= 0) { e.confL = 0; e.confR = 0; }
  } else {
    e.confL = smoothStep(e.confL, 0, 4 * 0.08, dt);
    e.confR = smoothStep(e.confR, 0, 4 * 0.08, dt);
  }

  // Auto-blink
  if (e.autoBlink && !e.sleeping && e.blinkLDir === 0 && e.mood !== 'happy') {
    e.blinkTimer -= dt;
    if (e.blinkTimer <= 0) {
      doBlink();
      e.blinkTimer = blinkMinS + Math.random() * (blinkMaxS - blinkMinS);
    }
  }

  // Happy expression: alternating winks
  if (e.mood === 'happy' && !e.sleeping && e.blinkLDir === 0 && e.blinkRDir === 0) {
    e.happyWinkTimer -= dt;
    if (e.happyWinkTimer <= 0) {
      if (e.happyWinkSide === 0) doWinkL();
      else doWinkR();
      e.happyWinkSide = 1 - e.happyWinkSide;
      e.happyWinkTimer = 0.8 + Math.random() * 1.2;
    }
  }

  // Auto-cycle expressions
  if (autoCycleEnabled && !e.sleeping) {
    autoCycleTimer += dtMs;
    if (autoCycleTimer >= autoCycleInterval) {
      const pick = weightedRandomExpression();
      setMood(pick);
      autoCycleTimer = 0;
      autoCycleInterval = exprMinMs + Math.random() * (exprMaxMs - exprMinMs);
    }
  }

  // Sequences
  if (activeSequence) {
    const now = performance.now();
    if (now >= activeSequence.untilMs) {
      activeSequence = null;
    } else if (activeSequence.name === 'boot') {
      const elapsed = now - activeSequence.startMs;
      if (elapsed > 650 && activeSequence.stage < 1) {
        activeSequence.stage = 1;
        setMood('happy');
      } else if (elapsed > 1100 && activeSequence.stage < 2) {
        activeSequence.stage = 2;
        setMood('normal');
      }
    }
  }

  updateStatus(dt);
  render();
  requestAnimationFrame(frame);
}

// ============================================================
// SERVER API: STATUS (poll every 1s)
// ============================================================
function fetchStatus() {
  fetch('/api/status')
    .then(r => r.ok ? r.json() : Promise.reject())
    .then(data => {
      setStatusText(data.text || '');
    })
    .catch(() => {});
}
setInterval(fetchStatus, 1000);
fetchStatus();

// ============================================================
// SERVER API: CONFIG (fetch once on startup)
// ============================================================
function rgb(arr) {
  if (!Array.isArray(arr) || arr.length < 3) return null;
  const r = clamp(arr[0] | 0, 0, 255);
  const g = clamp(arr[1] | 0, 0, 255);
  const b = clamp(arr[2] | 0, 0, 255);
  return `rgb(${r},${g},${b})`;
}

fetch('/api/config')
  .then(r => r.ok ? r.json() : Promise.reject())
  .then(cfg => {
    if (cfg.colors) {
      if (cfg.colors.background) {
        const c = rgb(cfg.colors.background);
        if (c) BG_COLOR = c;
      }
      if (cfg.colors.eye_color) {
        const c = rgb(cfg.colors.eye_color);
        if (c) EYE_COLOR = c;
      }
      // Backward compat: old configs may still have eye_white
      if (!cfg.colors.eye_color && cfg.colors.eye_white) {
        const c = rgb(cfg.colors.eye_white);
        if (c) EYE_COLOR = c;
      }
    }
    if (cfg.behavior) {
      if (cfg.behavior.blink_interval_min != null || cfg.behavior.blink_interval_max != null) {
        blinkMinS = cfg.behavior.blink_interval_min || 1.5;
        blinkMaxS = cfg.behavior.blink_interval_max || 4.0;
      }
      if (cfg.behavior.expression_interval_min != null || cfg.behavior.expression_interval_max != null) {
        exprMinMs = (cfg.behavior.expression_interval_min || 8) * 1000;
        exprMaxMs = (cfg.behavior.expression_interval_max || 20) * 1000;
        autoCycleInterval = exprMinMs + Math.random() * (exprMaxMs - exprMinMs);
      }
      if (cfg.behavior.look_interval_min != null || cfg.behavior.look_interval_max != null) {
        lookMinS = cfg.behavior.look_interval_min || 1.0;
        lookMaxS = cfg.behavior.look_interval_max || 3.0;
      }
    }
    if (cfg.display && cfg.display.fps != null) {
      TARGET_FPS = clamp(cfg.display.fps | 0, 1, 240);
      FRAME_TIME = 1000 / TARGET_FPS;
    }
  })
  .catch(() => {});

// ============================================================
// SERVER API: COMMAND (poll every 1s)
// ============================================================
function fetchCommand() {
  fetch('/api/command')
    .then(r => r.ok ? r.json() : Promise.reject())
    .then(cmd => {
      if (!cmd || typeof cmd !== 'object') return;

      if (typeof cmd.expression === 'string' && KNOWN_EXPRS.has(cmd.expression)) {
        setExpression(cmd.expression);
      }
      if (typeof cmd.auto_cycle === 'boolean') {
        autoCycleEnabled = cmd.auto_cycle;
        autoCycleTimer = 0;
      }

      if (typeof cmd.intensity === 'number' && Number.isFinite(cmd.intensity)) {
        cmdIntensity = clamp(cmd.intensity, 0, 1);
      } else if (!('intensity' in cmd)) {
        cmdIntensity = null;
      }

      if ('look' in cmd) {
        if (cmd.look && typeof cmd.look === 'object') {
          const x = cmd.look.x, y = cmd.look.y;
          if (typeof x === 'number' && typeof y === 'number' && Number.isFinite(x) && Number.isFinite(y)) {
            lookOverride = { x: clamp(x, -1, 1), y: clamp(y, -1, 1) };
          } else {
            lookOverride = null;
          }
        } else {
          lookOverride = null;
        }
      } else {
        lookOverride = null;
      }

      if (typeof cmd.blink_seq === 'number' && Number.isFinite(cmd.blink_seq)) {
        const v = cmd.blink_seq | 0;
        if (lastBlinkSeq === null) lastBlinkSeq = v;
        else if (v !== lastBlinkSeq) {
          lastBlinkSeq = v;
          doBlink();
        }
      }

      if (typeof cmd.sequence_seq === 'number' && Number.isFinite(cmd.sequence_seq)) {
        const v = cmd.sequence_seq | 0;
        if (lastSequenceSeq === null) lastSequenceSeq = v;
        else if (v !== lastSequenceSeq) {
          lastSequenceSeq = v;
          if (typeof cmd.sequence === 'string') startSequence(cmd.sequence);
        }
      }
    })
    .catch(() => {});
}
setInterval(fetchCommand, 1000);

// ============================================================
// KEYBOARD CONTROLS
// ============================================================
const MOOD_KEYS = ['1','2','3','4','5','6','7','8','9','0','-','=','q','w','e'];
const MOOD_NAMES = Object.keys(PRESETS);

function toggleFullscreen() {
  const el = document.documentElement;
  const can = !!(el.requestFullscreen && document.exitFullscreen);
  if (can) {
    if (document.fullscreenElement) {
      document.exitFullscreen().catch(() => {});
    } else {
      el.requestFullscreen().catch(() => {
        fetch('/api/fullscreen/toggle').catch(() => {});
      });
    }
    return;
  }
  fetch('/api/fullscreen/toggle').catch(() => {});
}

document.addEventListener('keydown', ev => {
  const k = ev.key;

  // Quit
  if (k === 'Escape' || k === 'Q') {
    fetch('/api/quit').catch(() => {});
    return;
  }

  // Toggle auto-cycle
  if (k === ' ') {
    autoCycleEnabled = !autoCycleEnabled;
    autoCycleTimer = 0;
    ev.preventDefault();
    return;
  }

  // Manual blink
  if (k === 'b' || k === 'B') {
    doBlink();
    ev.preventDefault();
    return;
  }

  // Fullscreen
  if (k === 'f' || k === 'F') {
    toggleFullscreen();
    return;
  }

  // Arrow keys: gaze override
  if (k === 'ArrowUp')    { eye.gazeTargX = 0; eye.gazeTargY = -1; ev.preventDefault(); return; }
  if (k === 'ArrowDown')  { eye.gazeTargX = 0; eye.gazeTargY = 1;  ev.preventDefault(); return; }
  if (k === 'ArrowLeft')  { eye.gazeTargX = -1; eye.gazeTargY = 0; ev.preventDefault(); return; }
  if (k === 'ArrowRight') { eye.gazeTargX = 1;  eye.gazeTargY = 0; ev.preventDefault(); return; }

  // Expression hotkeys: 1-9, 0, -, =, q, w, e
  const kk = (typeof k === 'string') ? k.toLowerCase() : '';
  const mi = MOOD_KEYS.indexOf(kk);
  if (mi >= 0 && mi < MOOD_NAMES.length) {
    eye.sleeping = false;
    setMood(MOOD_NAMES[mi]);
    return;
  }
});

document.addEventListener('keyup', ev => {
  const k = ev.key;
  if (k === 'ArrowUp' || k === 'ArrowDown') { eye.gazeTargY = 0; }
  if (k === 'ArrowLeft' || k === 'ArrowRight') { eye.gazeTargX = 0; }
});

// ============================================================
// START
// ============================================================
requestAnimationFrame(frame);
</script>
</body>
</html>
