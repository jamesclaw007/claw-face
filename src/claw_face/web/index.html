<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claw Face</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; cursor: none !important; }
    body {
      background: #000;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: none !important;
    }
    canvas { display: block; cursor: none !important; }
  </style>
</head>
<body>
  <canvas id="oled"></canvas>

<script>
// ============================================================
// OLED ROBOT EYES ENGINE — Cozmo-inspired parametric system
// Replaces dot-matrix renderer. Single-file, no external deps.
// ============================================================

const canvas = document.getElementById('oled');
const C = canvas.getContext('2d');

// Virtual OLED dimensions and scale
const VW = 128, VH = 64;
let S = 4; // scale factor, recalculated on resize

let EYE_COLOR = '#00b8ff';
let BG_COLOR = '#000000';

// Offscreen canvas for 1:1 virtual pixel rendering
const offCanvas = document.createElement('canvas');
offCanvas.width = VW;
offCanvas.height = VH;
const OC = offCanvas.getContext('2d', { willReadFrequently: true });

function resize() {
  // Fill the screen, maintaining the 2:1 aspect ratio of the virtual OLED
  const ww = window.innerWidth, wh = window.innerHeight;
  const aspect = VW / VH; // 2:1
  let w, h;
  if (ww / wh > aspect) {
    h = wh;
    w = h * aspect;
  } else {
    w = ww;
    h = w / aspect;
  }
  S = w / VW;
  canvas.width = Math.round(w);
  canvas.height = Math.round(h);
}
window.addEventListener('resize', resize);
resize();

// ============================================================
// EASING
// ============================================================
function lerp(a, b, t) { return a + (b - a) * t; }
function smoothStep(a, b, speed, dt) {
  return lerp(a, b, 1 - Math.pow(1 - speed, dt * 60));
}
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

// ============================================================
// EXPRESSION PRESETS (Cozmo/esp32-eyes style)
// Per-eye: w, h (size add), offY, tiltTop/tiltBot (lid angle px),
//   lidTop/lidBot (closure 0-1), scaleX
// ============================================================
const PRESETS = {
  normal: {
    L: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    R: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    catchlight: 1,
    transitionSpeed: 6,
  },
  happy: {
    L: { w:6, h:8, offY:-2, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    R: { w:6, h:8, offY:-2, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    catchlight: 1, transitionSpeed: 7,
  },
  sad: {
    L: { w:-2, h:-3, offY:2, tiltTop:5, tiltBot:0, lidTop:0.25, lidBot:0, scaleX:0.95 },
    R: { w:-2, h:-3, offY:2, tiltTop:-5, tiltBot:0, lidTop:0.25, lidBot:0, scaleX:0.95 },
    transitionSpeed: 4,
  },
  angry: {
    L: { w:3, h:-4, offY:0, tiltTop:-7, tiltBot:0, lidTop:0.38, lidBot:0, scaleX:1.08 },
    R: { w:3, h:-4, offY:0, tiltTop:7, tiltBot:0, lidTop:0.38, lidBot:0, scaleX:1.08 },
    transitionSpeed: 8,
  },
  surprised: {
    L: { w:6, h:8, offY:-2, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    R: { w:6, h:8, offY:-2, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    catchlight: 1,
    transitionSpeed: 10,
  },
  suspicious: {
    L: { w:1, h:-8, offY:1, tiltTop:-4, tiltBot:2, lidTop:0.30, lidBot:0.20, scaleX:1.1 },
    R: { w:-2, h:-4, offY:0, tiltTop:0, tiltBot:0, lidTop:0.10, lidBot:0, scaleX:0.9 },
    transitionSpeed: 5,
  },
  cute: {
    L: { w:5, h:5, offY:1, tiltTop:0, tiltBot:-2, lidTop:0, lidBot:0.30, scaleX:1 },
    R: { w:5, h:5, offY:1, tiltTop:0, tiltBot:2, lidTop:0, lidBot:0.30, scaleX:1 },
    catchlight: 1,
    transitionSpeed: 6,
  },
  tired: {
    L: { w:-1, h:-6, offY:3, tiltTop:3, tiltBot:0, lidTop:0.42, lidBot:0, scaleX:0.95 },
    R: { w:-1, h:-6, offY:3, tiltTop:-3, tiltBot:0, lidTop:0.42, lidBot:0, scaleX:0.95 },
    transitionSpeed: 3,
  },
  wonder: {
    L: { w:4, h:7, offY:-1, tiltTop:2, tiltBot:0, lidTop:0, lidBot:0, scaleX:0.95 },
    R: { w:6, h:9, offY:-2, tiltTop:-2, tiltBot:0, lidTop:0, lidBot:0, scaleX:1.05 },
    catchlight: 1,
    transitionSpeed: 6,
  },
  upset: {
    L: { w:0, h:-2, offY:2, tiltTop:6, tiltBot:-2, lidTop:0.18, lidBot:0.10, scaleX:1 },
    R: { w:0, h:-2, offY:2, tiltTop:-6, tiltBot:2, lidTop:0.18, lidBot:0.10, scaleX:1 },
    transitionSpeed: 5,
  },
  confused: {
    L: { w:-3, h:2, offY:-2, tiltTop:4, tiltBot:0, lidTop:0.15, lidBot:0, scaleX:0.9 },
    R: { w:4, h:4, offY:1, tiltTop:-2, tiltBot:0, lidTop:0, lidBot:0, scaleX:1.1 },
    catchlight: 0.7,
    transitionSpeed: 6,
  },
  scared: {
    L: { w:5, h:8, offY:-1, tiltTop:4, tiltBot:0, lidTop:0, lidBot:0.05, scaleX:0.92 },
    R: { w:5, h:8, offY:-1, tiltTop:-4, tiltBot:0, lidTop:0, lidBot:0.05, scaleX:0.92 },
    catchlight: 1,
    transitionSpeed: 10,
  },
  sleepy: {
    L: { w:-2, h:-12, offY:4, tiltTop:2, tiltBot:0, lidTop:0.55, lidBot:0, scaleX:1 },
    R: { w:-2, h:-12, offY:4, tiltTop:-2, tiltBot:0, lidTop:0.55, lidBot:0, scaleX:1 },
    transitionSpeed: 2,
  },
  glee: {
    L: { w:3, h:-4, offY:0, tiltTop:0, tiltBot:-5, lidTop:0, lidBot:0.50, scaleX:1.1 },
    R: { w:3, h:-4, offY:0, tiltTop:0, tiltBot:5, lidTop:0, lidBot:0.50, scaleX:1.1 },
    catchlight: 1,
    transitionSpeed: 8,
  },
  skeptic: {
    L: { w:0, h:0, offY:0, tiltTop:-5, tiltBot:0, lidTop:0.35, lidBot:0, scaleX:1 },
    R: { w:2, h:4, offY:-1, tiltTop:2, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    transitionSpeed: 5,
  },
  thinking: {
    L: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    R: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
    catchlight: 1,
    gazeAnim: {
      positions: [
        { x: -0.6, y: 0.6 },   // down-left (primary)
        { x: -0.6, y: 0.6 },   // repeat to weight toward down-left
        { x: 0.6, y: 0.6 },    // down-right (occasional)
      ],
      interval: [1.5, 3.5],    // seconds between switches [min, max]
    },
    transitionSpeed: 5,
  },
};

// Compatibility map: old expression names -> new canonical names
const COMPAT_MAP = {
  neutral: 'normal',
  love: 'cute',
  focused: 'suspicious',
  excited: 'glee',
  glitch: 'scared',
  smug: 'skeptic',
  sleep: 'sleepy',
};

// All known expression names (canonical + compat)
const KNOWN_EXPRS = new Set([
  ...Object.keys(PRESETS),
  ...Object.keys(COMPAT_MAP),
  'wink', 'talking', 'typing',
]);

// Resolve an expression name, applying compat mapping
function resolveExpr(name) {
  if (name === 'wink') return '__wink__';
  if (name === 'talking' || name === 'typing') return 'normal';
  if (PRESETS[name]) return name;
  if (COMPAT_MAP[name]) return COMPAT_MAP[name];
  return null;
}

// ============================================================
// EXPRESSION WEIGHTS (for auto-cycling)
// ============================================================
const EXPRESSION_WEIGHTS = {
  normal:     25,
  happy:      40,
  angry:       8,
  surprised:  12,
  sleepy:     15,
};

function weightedRandomExpression() {
  const names = Object.keys(EXPRESSION_WEIGHTS);
  const weights = names.map(n => EXPRESSION_WEIGHTS[n]);
  const total = weights.reduce((s, w) => s + w, 0);
  let r = Math.random() * total;
  for (let i = 0; i < names.length; i++) {
    r -= weights[i];
    if (r <= 0) return names[i];
  }
  return names[names.length - 1];
}

// ============================================================
// STATE
// ============================================================
const eye = {
  baseW: 28, baseH: 36, gap: 40, cornerR: 8,
  // Current per-eye interpolated state
  L: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
  R: { w:0, h:0, offY:0, tiltTop:0, tiltBot:0, lidTop:0, lidBot:0, scaleX:1 },
  // Gaze
  gazeTargX: 0, gazeTargY: 0, gazeX: 0, gazeY: 0,
  // Blink (0=open, 1=closed)
  blinkL: 0, blinkR: 0, blinkLDir: 0, blinkRDir: 0,
  // Sleeping
  sleeping: false, sleepT: 0,
  // Confusion offset
  confL: 0, confR: 0, confTimer: 0,
  // Transition speed
  tSpeed: 6,
  // Pupil scale modifier
  pupilScale: 1,
  // Catchlight (0=none, 1=bright reflection dot in pupil)
  catchlight: 0,
  // Current mood
  mood: 'normal',
  // Toggles
  autoBlink: true,
  // Timers
  blinkTimer: 2 + Math.random() * 3,
};

// Auto-cycle
let autoCycleEnabled = true;
let autoCycleTimer = 0;
let exprMinMs = 8000;
let exprMaxMs = 20000;
let autoCycleInterval = exprMinMs + Math.random() * (exprMaxMs - exprMinMs);

// Blink timing (configurable from /api/config)
let blinkMinS = 1.5;
let blinkMaxS = 4.0;

// Look timing
let lookMinS = 1.0;
let lookMaxS = 3.0;

// External command state
let cmdIntensity = null;
let lookOverride = null;
let lastBlinkSeq = null;
let lastSequenceSeq = null;
let activeSequence = null;

// FPS throttle
let TARGET_FPS = 30;
let FRAME_TIME = 1000 / TARGET_FPS;

function setMood(name) {
  if (!PRESETS[name]) return;
  eye.mood = name;
  eye.tSpeed = PRESETS[name].transitionSpeed;
}

function setExpression(rawName) {
  const resolved = resolveExpr(rawName);
  if (!resolved) return;
  if (resolved === '__wink__') {
    doWinkL();
    setMood('happy');
    return;
  }
  eye.sleeping = false;
  setMood(resolved);
}

// ============================================================
// DRAWING PRIMITIVES
// ============================================================
function fillRoundRect(x, y, w, h, r) {
  r = Math.min(r, w / 2, h / 2);
  if (r < 0) r = 0;
  OC.beginPath();
  OC.moveTo(x + r, y);
  OC.lineTo(x + w - r, y);
  OC.quadraticCurveTo(x + w, y, x + w, y + r);
  OC.lineTo(x + w, y + h - r);
  OC.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  OC.lineTo(x + r, y + h);
  OC.quadraticCurveTo(x, y + h, x, y + h - r);
  OC.lineTo(x, y + r);
  OC.quadraticCurveTo(x, y, x + r, y);
  OC.closePath();
  OC.fill();
}

function drawEye(cx, cy, baseW, baseH, r, ep, blink, pupilScale, gazeX, gazeY, catchlight) {
  const ew = (baseW + ep.w) * ep.scaleX;
  const fullH = baseH + ep.h;
  const minH = 3;
  const eh = Math.max(minH, fullH * (1 - blink));
  const oy = ep.offY * (1 - blink * 0.7);
  const x = cx - ew / 2;
  const y = cy - eh / 2 + oy;
  const cl = catchlight || 0;

  // Main eye shape
  OC.fillStyle = EYE_COLOR;
  fillRoundRect(x, y, ew, eh, Math.min(r, eh / 2));

  // Pupil — only when eye is open enough
  if (eh > 8) {
    const ps = pupilScale || 1;
    const pupilW = ew * 0.38 * ps;
    const pupilH = eh * 0.40 * ps;
    const maxShiftX = (ew - pupilW) * 0.45;
    const maxShiftY = (eh - pupilH) * 0.45;
    const pcx = cx + gazeX * maxShiftX;
    const pcy = cy + oy + gazeY * maxShiftY;

    OC.fillStyle = BG_COLOR;
    const pupilR = Math.min(Math.min(r, pupilW / 2, pupilH / 2), 6 * ps);
    const px = pcx - pupilW / 2;
    const py = pcy - pupilH / 2;
    fillRoundRect(px, py, pupilW, pupilH, pupilR);

    // Catchlight — small bright dot in upper-right of pupil
    if (cl > 0.01) {
      const dotR = Math.min(pupilW, pupilH) * 0.18 * cl;
      const dotX = pcx + pupilW * 0.18;
      const dotY = pcy - pupilH * 0.18;
      OC.fillStyle = EYE_COLOR;
      OC.beginPath();
      OC.arc(dotX, dotY, dotR, 0, Math.PI * 2);
      OC.fill();
    }
  }

  // Angled top lid
  if (ep.lidTop > 0.02 || Math.abs(ep.tiltTop) > 0.5) {
    const lidH = eh * Math.max(ep.lidTop, 0) + Math.abs(ep.tiltTop);
    if (lidH > 0.5) {
      OC.fillStyle = BG_COLOR;
      OC.beginPath();
      const lx = x - 2, rx = x + ew + 2;
      const lyTop = y - 3;
      const lyBot = y + lidH + ep.tiltTop;
      const ryBot = y + lidH - ep.tiltTop;
      OC.moveTo(lx, lyTop); OC.lineTo(rx, lyTop);
      OC.lineTo(rx, ryBot); OC.lineTo(lx, lyBot);
      OC.closePath(); OC.fill();
    }
  }

  // Angled bottom lid
  if (ep.lidBot > 0.02 || Math.abs(ep.tiltBot) > 0.5) {
    const lidH = eh * Math.max(ep.lidBot, 0) + Math.abs(ep.tiltBot);
    if (lidH > 0.5) {
      OC.fillStyle = BG_COLOR;
      OC.beginPath();
      const lx = x - 2, rx = x + ew + 2;
      const lyBot = y + eh + 3;
      const lyTop = y + eh - lidH + ep.tiltBot;
      const ryTop = y + eh - lidH - ep.tiltBot;
      OC.moveTo(lx, lyTop); OC.lineTo(rx, ryTop);
      OC.lineTo(rx, lyBot); OC.lineTo(lx, lyBot);
      OC.closePath(); OC.fill();
    }
  }
}

// ============================================================
// STATUS TICKER (typing/hold/erase state machine)
// ============================================================
const statusState = {
  currentText: '',   // what we're currently displaying/targeting
  displayText: '',   // what's visible right now
  charIdx: 0,
  phase: 'idle',     // 'idle' | 'typing' | 'hold' | 'erasing' | 'erase_then_type'
  timer: 0,
  typeSpeed: 0.04,
  eraseSpeed: 0.02,
  pendingText: null,  // queued text to type after erase
  serverText: '',     // last text received from server
  cursorBlinkTimer: 0,  // slow blink timer for block cursor
  cursorVisible: true,  // cursor blink state
};

function setStatusText(text) {
  const ss = statusState;
  if (text === ss.serverText) return;
  ss.serverText = text;

  if (!text) {
    // Empty: erase current and go idle
    if (ss.displayText) {
      ss.phase = 'erasing';
      ss.pendingText = null;
      ss.timer = 0;
    } else {
      ss.phase = 'idle';
    }
    return;
  }

  if (ss.phase === 'idle' && !ss.displayText) {
    // Nothing showing — type it directly
    ss.currentText = text;
    ss.charIdx = 0;
    ss.displayText = '';
    ss.phase = 'typing';
    ss.timer = 0;
  } else {
    // Something showing — erase first, then type new
    ss.pendingText = text;
    if (ss.phase !== 'erasing' && ss.phase !== 'erase_then_type') {
      ss.phase = 'erase_then_type';
      ss.timer = 0;
    }
  }
}

function updateStatus(dt) {
  const ss = statusState;
  if (ss.phase === 'idle') return;
  ss.timer += dt;

  if (ss.phase === 'typing') {
    if (ss.timer >= ss.typeSpeed) {
      ss.timer = 0;
      ss.charIdx++;
      ss.displayText = ss.currentText.substring(0, ss.charIdx);
      if (ss.charIdx >= ss.currentText.length) {
        ss.phase = 'hold';
        ss.timer = 0;
      }
    }
  } else if (ss.phase === 'hold') {
    if (ss.pendingText != null) {
      // New text waiting — start erasing
      ss.phase = 'erase_then_type';
      ss.timer = 0;
    }
    // No auto-erase — status persists until server clears or changes it
  } else if (ss.phase === 'erasing' || ss.phase === 'erase_then_type') {
    if (ss.timer >= ss.eraseSpeed) {
      ss.timer = 0;
      ss.charIdx--;
      ss.displayText = ss.currentText.substring(0, Math.max(0, ss.charIdx));
      if (ss.charIdx <= 0) {
        if (ss.phase === 'erase_then_type' && ss.pendingText) {
          ss.currentText = ss.pendingText;
          ss.pendingText = null;
          ss.charIdx = 0;
          ss.displayText = '';
          ss.phase = 'typing';
          ss.timer = 0;
        } else {
          ss.displayText = '';
          ss.phase = 'idle';
          ss.pendingText = null;
        }
      }
    }
  }

  // Slow cursor blink (1.2s interval, not distracting)
  ss.cursorBlinkTimer += dt;
  if (ss.cursorBlinkTimer >= 1.2) {
    ss.cursorBlinkTimer = 0;
    ss.cursorVisible = !ss.cursorVisible;
  }
}

// 3x5 bitmap font for status ticker (each glyph: 5 rows of 3-bit masks)
const FONT_3x5 = {
  'A':[7,5,7,5,5],'B':[6,5,6,5,6],'C':[7,4,4,4,7],'D':[6,5,5,5,6],
  'E':[7,4,7,4,7],'F':[7,4,7,4,4],'G':[7,4,5,5,7],'H':[5,5,7,5,5],
  'I':[7,2,2,2,7],'J':[3,1,1,5,7],'K':[5,6,4,6,5],'L':[4,4,4,4,7],
  'M':[5,7,5,5,5],'N':[5,7,7,5,5],'O':[7,5,5,5,7],'P':[7,5,7,4,4],
  'Q':[7,5,5,7,1],'R':[7,5,7,6,5],'S':[7,4,7,1,7],'T':[7,2,2,2,2],
  'U':[5,5,5,5,7],'V':[5,5,5,5,2],'W':[5,5,5,7,5],'X':[5,5,2,5,5],
  'Y':[5,5,7,2,2],'Z':[7,1,2,4,7],
  '0':[7,5,5,5,7],'1':[2,6,2,2,7],'2':[7,1,7,4,7],'3':[7,1,7,1,7],
  '4':[5,5,7,1,1],'5':[7,4,7,1,7],'6':[7,4,7,5,7],'7':[7,1,1,1,1],
  '8':[7,5,7,5,7],'9':[7,5,7,1,7],
  '.':[0,0,0,0,2],',':[0,0,0,2,4],'!':[2,2,2,0,2],'?':[7,1,3,0,2],
  ':':[0,2,0,2,0],'-':[0,0,7,0,0],'+':[0,2,7,2,0],'=':[0,7,0,7,0],
  '/':[1,1,2,4,4],'(':[1,2,2,2,1],')':[4,2,2,2,4],
  '\'':[2,2,0,0,0],'"':[5,5,0,0,0],'_':[0,0,0,0,7],
  ' ':[0,0,0,0,0],
};

function wrapText(text, maxCharsPerLine) {
  // Split text into lines with word-wrap support
  const words = text.split(' ');
  const lines = [];
  let currentLine = '';

  for (const word of words) {
    const testLine = currentLine ? currentLine + ' ' + word : word;
    if (testLine.length <= maxCharsPerLine) {
      currentLine = testLine;
    } else {
      if (currentLine) lines.push(currentLine);
      // If single word is too long, force split it
      if (word.length > maxCharsPerLine) {
        for (let i = 0; i < word.length; i += maxCharsPerLine) {
          lines.push(word.substring(i, i + maxCharsPerLine));
        }
        currentLine = '';
      } else {
        currentLine = word;
      }
    }
  }
  if (currentLine) lines.push(currentLine);
  return lines;
}

function renderBitmapStatus() {
  const ss = statusState;
  if (!ss.displayText && ss.phase === 'idle') return;

  const text = (ss.displayText || '').toUpperCase();
  const statusColor = '#006a8a';
  OC.fillStyle = statusColor;

  const charW = 4; // 4px per char cell (3px glyph + 1px gap)
  const lineH = 6; // 5px font + 1px gap between lines
  const maxChars = 30; // max characters per line

  // Word-wrap into lines (max 2 lines)
  const lines = wrapText(text, maxChars).slice(0, 2);
  
  // Calculate starting Y position to center multi-line text
  const totalHeight = lines.length * lineH - 1;
  let startY = 57; // single line baseline
  if (lines.length === 2) startY = 54; // shift up for 2 lines

  // Render each line
  for (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {
    const line = lines[lineIdx];
    const lineW = line.length * charW;
    const startX = Math.floor((VW - lineW) / 2);
    const y = startY + lineIdx * lineH;

    for (let i = 0; i < line.length; i++) {
      const glyph = FONT_3x5[line[i]];
      if (!glyph) continue;
      const cx = startX + i * charW;
      for (let row = 0; row < 5; row++) {
        const bits = glyph[row];
        for (let col = 0; col < 3; col++) {
          if (bits & (4 >> col)) {
            OC.fillRect(cx + col, y + row, 1, 1);
          }
        }
      }
    }

    // Cursor — 3x5 block after last line's text with slow blink
    if (lineIdx === lines.length - 1 && (ss.phase === 'typing' || ss.phase === 'hold')) {
      if (ss.cursorVisible) {
        const cursorX = startX + line.length * charW + 1;
        for (let row = 0; row < 5; row++) {
          OC.fillRect(cursorX, y + row, 3, 1);  // 3px wide block
        }
      }
    }
  }
}

// ============================================================
// ACTIONS
// ============================================================
function doBlink() {
  eye.blinkLDir = 1; eye.blinkL = 0;
  eye.blinkRDir = 1; eye.blinkR = 0;
}
function doWinkL() { eye.blinkLDir = 1; eye.blinkL = 0; }
function doWinkR() { eye.blinkRDir = 1; eye.blinkR = 0; }

// ============================================================
// SEQUENCES (boot, error_pulse, yawn)
// ============================================================

// Yawn state
let yawnTimer = 8 + Math.random() * 12; // seconds until next yawn
const YAWN_MIN_INTERVAL = 15; // min seconds between yawns
const YAWN_MAX_INTERVAL = 40; // max seconds between yawns

function startSequence(name) {
  const n = typeof name === 'string' ? name : '';
  const now = performance.now();
  if (n === 'boot') {
    activeSequence = { name: 'boot', untilMs: now + 1600, stage: 0, startMs: now };
    setExpression('glee');
    doBlink();
    return;
  }
  if (n === 'error_pulse') {
    activeSequence = { name: 'error_pulse', untilMs: now + 900, stage: 0, startMs: now };
    setExpression('scared');
    return;
  }
  if (n === 'yawn') {
    // Yawn: 4 seconds total
    // 0-1.2s: eyes slowly close (slower than blink), slight upward gaze
    // 1.2-2.5s: hold shut
    // 2.5-4.0s: slowly half-open back to sleepy
    activeSequence = { name: 'yawn', untilMs: now + 4000, stage: 0, startMs: now };
    return;
  }
}

function updateYawnSequence(dt) {
  if (!activeSequence || activeSequence.name !== 'yawn') return;
  const elapsed = (performance.now() - activeSequence.startMs) / 1000;
  const e = eye;

  if (elapsed < 1.2) {
    // Stage 0: slowly closing — override blink values directly
    const t = elapsed / 1.2; // 0→1
    const eased = t * t; // ease-in (accelerate)
    e.blinkL = Math.max(e.blinkL, eased);
    e.blinkR = Math.max(e.blinkR, eased);
    e.blinkLDir = 0; e.blinkRDir = 0; // prevent normal blink from interfering
    // Slight upward gaze during yawn
    e.gazeTargY = -0.3 * eased;
    if (activeSequence.stage < 1) activeSequence.stage = 1;
  } else if (elapsed < 2.5) {
    // Stage 1: held shut
    e.blinkL = 1; e.blinkR = 1;
    e.blinkLDir = 0; e.blinkRDir = 0;
    e.gazeTargY = -0.3;
  } else {
    // Stage 2: slowly opening back to half-closed (sleepy)
    const t = (elapsed - 2.5) / 1.5; // 0→1
    const eased = 1 - (1 - t) * (1 - t); // ease-out
    const target = 0.92; // sleepy half-closed level (sleepT covers the rest)
    e.blinkL = 1 - eased * (1 - target);
    e.blinkR = 1 - eased * (1 - target);
    e.blinkLDir = 0; e.blinkRDir = 0;
    // Gaze drifts back to center
    e.gazeTargY = -0.3 * (1 - eased);
  }
}

// ============================================================
// RENDER
// ============================================================
function render() {
  // Phase 1: Draw at 1:1 on offscreen canvas
  OC.fillStyle = BG_COLOR;
  OC.fillRect(0, 0, VW, VH);

  const e = eye;
  const leftCX = VW / 2 - e.gap / 2 + e.confL;
  const rightCX = VW / 2 + e.gap / 2 + e.confR;
  const cy = VH / 2 - 5;

  const sleepBlink = e.sleepT * 0.92;
  const blinkL = Math.max(e.blinkL, sleepBlink);
  const blinkR = Math.max(e.blinkR, sleepBlink);

  drawEye(leftCX, cy, e.baseW, e.baseH, e.cornerR, e.L, blinkL, e.pupilScale, e.gazeX, e.gazeY, e.catchlight);
  drawEye(rightCX, cy, e.baseW, e.baseH, e.cornerR, e.R, blinkR, e.pupilScale, e.gazeX, e.gazeY, e.catchlight);

  renderBitmapStatus();

  // Phase 2: Read pixels and draw as discrete LED dots on main canvas
  C.fillStyle = BG_COLOR;
  C.fillRect(0, 0, canvas.width, canvas.height);

  const imgData = OC.getImageData(0, 0, VW, VH);
  const px = imgData.data;
  const gap = Math.max(1, Math.round(S * 0.15));
  const dotSize = Math.max(1, Math.round(S) - gap);

  // Batch pixels by color to minimize fillStyle changes
  const batches = {};
  for (let y = 0; y < VH; y++) {
    for (let x = 0; x < VW; x++) {
      const i = (y * VW + x) * 4;
      const r = px[i], g = px[i + 1], b = px[i + 2];
      // Skip black/near-black pixels (background + anti-alias cleanup)
      if (r + g + b < 40) continue;
      const key = (r << 16) | (g << 8) | b;
      if (!batches[key]) batches[key] = { color: `rgb(${r},${g},${b})`, dots: [] };
      batches[key].dots.push(x, y);
    }
  }

  for (const key in batches) {
    const batch = batches[key];
    C.fillStyle = batch.color;
    const dots = batch.dots;
    for (let j = 0; j < dots.length; j += 2) {
      C.fillRect(Math.round(dots[j] * S), Math.round(dots[j + 1] * S), dotSize, dotSize);
    }
  }
}

// ============================================================
// UPDATE LOOP
// ============================================================
let lastT = 0;
let accumulator = 0;

function frame(ts) {
  const elapsed = ts - lastT;
  lastT = ts;
  accumulator += elapsed;

  if (accumulator < FRAME_TIME) {
    requestAnimationFrame(frame);
    return;
  }
  const dtMs = Math.min(accumulator, 50);
  const dt = dtMs / 1000;
  accumulator = 0;

  const e = eye;
  const spd = e.tSpeed;
  const preset = PRESETS[e.mood];

  // Interpolate per-eye params toward preset
  const fields = ['w', 'h', 'offY', 'tiltTop', 'tiltBot', 'lidTop', 'lidBot', 'scaleX'];
  for (const f of fields) {
    e.L[f] = smoothStep(e.L[f], preset.L[f], spd * 0.08, dt);
    e.R[f] = smoothStep(e.R[f], preset.R[f], spd * 0.08, dt);
  }

  // Interpolate pupil scale
  const targetPS = preset.pupilScale || 1;
  e.pupilScale = smoothStep(e.pupilScale, targetPS, spd * 0.08, dt);

  // Interpolate catchlight
  const targetCL = preset.catchlight || 0;
  e.catchlight = smoothStep(e.catchlight, targetCL, spd * 0.08, dt);

  // Gaze animation (e.g., thinking eyes darting between positions)
  if (preset.gazeAnim && !lookOverride) {
    if (!e._gazeAnimTimer) e._gazeAnimTimer = 0;
    if (!e._gazeAnimIdx) e._gazeAnimIdx = 0;
    e._gazeAnimTimer -= dt;
    if (e._gazeAnimTimer <= 0) {
      const positions = preset.gazeAnim.positions;
      e._gazeAnimIdx = (e._gazeAnimIdx + 1) % positions.length;
      const [minI, maxI] = preset.gazeAnim.interval;
      e._gazeAnimTimer = minI + Math.random() * (maxI - minI);
    }
  }

  // Gaze smoothing
  let gazeTargX = e.gazeTargX, gazeTargY = e.gazeTargY;
  if (lookOverride) {
    gazeTargX = lookOverride.x;
    gazeTargY = lookOverride.y;
  } else if (preset.gazeAnim) {
    const pos = preset.gazeAnim.positions[e._gazeAnimIdx || 0];
    gazeTargX = pos.x;
    gazeTargY = pos.y;
  } else if (preset.gaze) {
    // Apply preset gaze (e.g., thinking looks up)
    gazeTargX = preset.gaze.x || 0;
    gazeTargY = preset.gaze.y || 0;
  }
  const gazeSpd = (lookOverride || preset.gaze || e.gazeTargX !== 0 || e.gazeTargY !== 0) ? 8 * 0.08 : 2 * 0.08;
  e.gazeX = smoothStep(e.gazeX, gazeTargX, gazeSpd, dt);
  e.gazeY = smoothStep(e.gazeY, gazeTargY, gazeSpd, dt);

  // Blink animation
  if (e.blinkLDir) {
    e.blinkL += e.blinkLDir * 0.18 * dt * 60;
    if (e.blinkL >= 1) { e.blinkL = 1; e.blinkLDir = -1; }
    if (e.blinkL <= 0) { e.blinkL = 0; e.blinkLDir = 0; }
  }
  if (e.blinkRDir) {
    e.blinkR += e.blinkRDir * 0.18 * dt * 60;
    if (e.blinkR >= 1) { e.blinkR = 1; e.blinkRDir = -1; }
    if (e.blinkR <= 0) { e.blinkR = 0; e.blinkRDir = 0; }
  }

  // Sleep
  if (e.sleeping) e.sleepT = Math.min(1, e.sleepT + dt * 1.5);
  else e.sleepT = Math.max(0, e.sleepT - dt * 3);

  // Confusion decay
  if (e.confTimer > 0) {
    e.confTimer -= dt;
    if (e.confTimer <= 0) { e.confL = 0; e.confR = 0; }
  } else {
    e.confL = smoothStep(e.confL, 0, 4 * 0.08, dt);
    e.confR = smoothStep(e.confR, 0, 4 * 0.08, dt);
  }

  // Auto-blink
  if (e.autoBlink && !e.sleeping && e.blinkLDir === 0) {
    e.blinkTimer -= dt;
    if (e.blinkTimer <= 0) {
      doBlink();
      e.blinkTimer = blinkMinS + Math.random() * (blinkMaxS - blinkMinS);
    }
  }

  // Auto-cycle expressions
  if (autoCycleEnabled && !e.sleeping) {
    autoCycleTimer += dtMs;
    if (autoCycleTimer >= autoCycleInterval) {
      const pick = weightedRandomExpression();
      setMood(pick);
      autoCycleTimer = 0;
      autoCycleInterval = exprMinMs + Math.random() * (exprMaxMs - exprMinMs);
    }
  }

  // Yawn timer — trigger yawns periodically when in sleepy mood
  if (e.mood === 'sleepy' && !activeSequence) {
    yawnTimer -= dt;
    if (yawnTimer <= 0) {
      startSequence('yawn');
      yawnTimer = YAWN_MIN_INTERVAL + Math.random() * (YAWN_MAX_INTERVAL - YAWN_MIN_INTERVAL);
    }
  }

  // Sequences
  if (activeSequence) {
    const now = performance.now();
    if (now >= activeSequence.untilMs) {
      activeSequence = null;
    } else if (activeSequence.name === 'boot') {
      const elapsed = now - activeSequence.startMs;
      if (elapsed > 650 && activeSequence.stage < 1) {
        activeSequence.stage = 1;
        setMood('happy');
      } else if (elapsed > 1100 && activeSequence.stage < 2) {
        activeSequence.stage = 2;
        setMood('normal');
      }
    }
    // Run yawn animation updates
    updateYawnSequence(dt);
  }

  updateStatus(dt);
  render();
  requestAnimationFrame(frame);
}

// ============================================================
// SERVER API: SSE (replaces polling for status + command)
// ============================================================
function handleStatusEvent(data) {
  setStatusText(data.text || '');
}

function handleCommandEvent(cmd) {
  if (!cmd || typeof cmd !== 'object') return;

  if (typeof cmd.expression === 'string' && KNOWN_EXPRS.has(cmd.expression)) {
    setExpression(cmd.expression);
  }
  if (typeof cmd.auto_cycle === 'boolean') {
    autoCycleEnabled = cmd.auto_cycle;
    autoCycleTimer = 0;
  }

  if (typeof cmd.intensity === 'number' && Number.isFinite(cmd.intensity)) {
    cmdIntensity = clamp(cmd.intensity, 0, 1);
  } else if (!('intensity' in cmd)) {
    cmdIntensity = null;
  }

  if ('look' in cmd) {
    if (cmd.look && typeof cmd.look === 'object') {
      const x = cmd.look.x, y = cmd.look.y;
      if (typeof x === 'number' && typeof y === 'number' && Number.isFinite(x) && Number.isFinite(y)) {
        lookOverride = { x: clamp(x, -1, 1), y: clamp(y, -1, 1) };
      } else {
        lookOverride = null;
      }
    } else {
      lookOverride = null;
    }
  } else {
    lookOverride = null;
  }

  if (typeof cmd.blink_seq === 'number' && Number.isFinite(cmd.blink_seq)) {
    const v = cmd.blink_seq | 0;
    if (lastBlinkSeq === null) lastBlinkSeq = v;
    else if (v !== lastBlinkSeq) {
      lastBlinkSeq = v;
      doBlink();
    }
  }

  if (typeof cmd.sequence_seq === 'number' && Number.isFinite(cmd.sequence_seq)) {
    const v = cmd.sequence_seq | 0;
    if (lastSequenceSeq === null) lastSequenceSeq = v;
    else if (v !== lastSequenceSeq) {
      lastSequenceSeq = v;
      if (typeof cmd.sequence === 'string') startSequence(cmd.sequence);
    }
  }
}

const sse = new EventSource('/api/events');
sse.addEventListener('status', ev => {
  try { handleStatusEvent(JSON.parse(ev.data)); } catch(e) {}
});
sse.addEventListener('command', ev => {
  try { handleCommandEvent(JSON.parse(ev.data)); } catch(e) {}
});

// ============================================================
// SERVER API: CONFIG (fetch once on startup)
// ============================================================
function rgb(arr) {
  if (!Array.isArray(arr) || arr.length < 3) return null;
  const r = clamp(arr[0] | 0, 0, 255);
  const g = clamp(arr[1] | 0, 0, 255);
  const b = clamp(arr[2] | 0, 0, 255);
  return `rgb(${r},${g},${b})`;
}

fetch('/api/config')
  .then(r => r.ok ? r.json() : Promise.reject())
  .then(cfg => {
    if (cfg.colors) {
      if (cfg.colors.background) {
        const c = rgb(cfg.colors.background);
        if (c) BG_COLOR = c;
      }
      if (cfg.colors.eye_color) {
        const c = rgb(cfg.colors.eye_color);
        if (c) EYE_COLOR = c;
      }
      // Backward compat: old configs may still have eye_white
      if (!cfg.colors.eye_color && cfg.colors.eye_white) {
        const c = rgb(cfg.colors.eye_white);
        if (c) EYE_COLOR = c;
      }
    }
    if (cfg.behavior) {
      if (cfg.behavior.blink_interval_min != null || cfg.behavior.blink_interval_max != null) {
        blinkMinS = cfg.behavior.blink_interval_min || 1.5;
        blinkMaxS = cfg.behavior.blink_interval_max || 4.0;
      }
      if (cfg.behavior.expression_interval_min != null || cfg.behavior.expression_interval_max != null) {
        exprMinMs = (cfg.behavior.expression_interval_min || 8) * 1000;
        exprMaxMs = (cfg.behavior.expression_interval_max || 20) * 1000;
        autoCycleInterval = exprMinMs + Math.random() * (exprMaxMs - exprMinMs);
      }
      if (cfg.behavior.look_interval_min != null || cfg.behavior.look_interval_max != null) {
        lookMinS = cfg.behavior.look_interval_min || 1.0;
        lookMaxS = cfg.behavior.look_interval_max || 3.0;
      }
    }
    if (cfg.display && cfg.display.fps != null) {
      TARGET_FPS = clamp(cfg.display.fps | 0, 1, 240);
      FRAME_TIME = 1000 / TARGET_FPS;
    }
  })
  .catch(() => {});


// ============================================================
// KEYBOARD CONTROLS
// ============================================================
const MOOD_KEYS = ['1','2','3','4','5','6','7','8','9','0','-','=','q','w','e'];
const MOOD_NAMES = Object.keys(PRESETS);

function toggleFullscreen() {
  const el = document.documentElement;
  const can = !!(el.requestFullscreen && document.exitFullscreen);
  if (can) {
    if (document.fullscreenElement) {
      document.exitFullscreen().catch(() => {});
    } else {
      el.requestFullscreen().catch(() => {
        fetch('/api/fullscreen/toggle').catch(() => {});
      });
    }
    return;
  }
  fetch('/api/fullscreen/toggle').catch(() => {});
}

document.addEventListener('keydown', ev => {
  const k = ev.key;

  // Quit
  if (k === 'Escape' || k === 'Q') {
    fetch('/api/quit').catch(() => {});
    return;
  }

  // Toggle auto-cycle
  if (k === ' ') {
    autoCycleEnabled = !autoCycleEnabled;
    autoCycleTimer = 0;
    ev.preventDefault();
    return;
  }

  // Manual blink
  if (k === 'b' || k === 'B') {
    doBlink();
    ev.preventDefault();
    return;
  }

  // Fullscreen
  if (k === 'f' || k === 'F') {
    toggleFullscreen();
    return;
  }

  // Arrow keys: gaze override
  if (k === 'ArrowUp')    { eye.gazeTargX = 0; eye.gazeTargY = -1; ev.preventDefault(); return; }
  if (k === 'ArrowDown')  { eye.gazeTargX = 0; eye.gazeTargY = 1;  ev.preventDefault(); return; }
  if (k === 'ArrowLeft')  { eye.gazeTargX = -1; eye.gazeTargY = 0; ev.preventDefault(); return; }
  if (k === 'ArrowRight') { eye.gazeTargX = 1;  eye.gazeTargY = 0; ev.preventDefault(); return; }

  // Expression hotkeys: 1-9, 0, -, =, q, w, e
  const kk = (typeof k === 'string') ? k.toLowerCase() : '';
  const mi = MOOD_KEYS.indexOf(kk);
  if (mi >= 0 && mi < MOOD_NAMES.length) {
    eye.sleeping = false;
    setMood(MOOD_NAMES[mi]);
    return;
  }
});

document.addEventListener('keyup', ev => {
  const k = ev.key;
  if (k === 'ArrowUp' || k === 'ArrowDown') { eye.gazeTargY = 0; }
  if (k === 'ArrowLeft' || k === 'ArrowRight') { eye.gazeTargX = 0; }
});

// ============================================================
// START
// ============================================================
requestAnimationFrame(frame);
</script>
</body>
</html>
